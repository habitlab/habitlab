// Generated by src/generate-spec.js. 

/**
 * Copyright 2015 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Hack to make Babel6 import this as a module.
Object.defineProperty(exports, "__esModule", {
  value: true
});

// Meta data generated from spec.idl.
exports.default = (function() {
  var SPEC = {};

  var BOOLEAN = { typeName: "Boolean" };
  var DOUBLE = { typeName: "Number" };
  var STRING = { typeName: "String" };
  function Maybe(arg) { return { typeName: "Maybe", argument: arg }; }
  function List(arg) { return { typeName: "List", argument: arg }; }
  function Const(arg) { return { typeName: "Const", argument: arg }; }
  function Union() { return { typeName: "Union", arguments: [].slice.call(arguments, 0) }; }

  var TYPE_INDICATOR = {
    typeName: "Enum",
    values: ["ArrayBinding", "ArrayExpression", "ArrowExpression", "AssignmentExpression", "BinaryExpression", "BindingIdentifier", "BindingProperty", "BindingPropertyIdentifier", "BindingPropertyProperty", "BindingWithDefault", "Block", "BlockStatement", "BreakStatement", "CallExpression", "CatchClause", "Class", "ClassDeclaration", "ClassElement", "ClassExpression", "CompoundAssignmentExpression", "ComputedMemberExpression", "ComputedPropertyName", "ConditionalExpression", "ContinueStatement", "DataProperty", "DebuggerStatement", "Directive", "DoWhileStatement", "EmptyStatement", "Export", "ExportAllFrom", "ExportDeclaration", "ExportDefault", "ExportFrom", "ExportSpecifier", "Expression", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FormalParameters", "Function", "FunctionBody", "FunctionDeclaration", "FunctionExpression", "Getter", "IdentifierExpression", "IfStatement", "Import", "ImportDeclaration", "ImportNamespace", "ImportSpecifier", "IterationStatement", "LabeledStatement", "LiteralBooleanExpression", "LiteralInfinityExpression", "LiteralNullExpression", "LiteralNumericExpression", "LiteralRegExpExpression", "LiteralStringExpression", "MemberExpression", "Method", "MethodDefinition", "Module", "NamedObjectProperty", "NewExpression", "NewTargetExpression", "Node", "ObjectBinding", "ObjectExpression", "ObjectProperty", "PropertyName", "ReturnStatement", "Script", "Setter", "ShorthandProperty", "SourceLocation", "SourceSpan", "SpreadElement", "Statement", "StaticMemberExpression", "StaticPropertyName", "Super", "SwitchCase", "SwitchDefault", "SwitchStatement", "SwitchStatementWithDefault", "TemplateElement", "TemplateExpression", "ThisExpression", "ThrowStatement", "TryCatchStatement", "TryFinallyStatement", "UnaryExpression", "UpdateExpression", "VariableDeclaration", "VariableDeclarationStatement", "VariableDeclarator", "WhileStatement", "WithStatement", "YieldExpression", "YieldGeneratorExpression"]
  };

  var VariableDeclarationKind = {
    typeName: "Enum",
    values: ["var", "let", "const"]
  };

  var CompoundAssignmentOperator = {
    typeName: "Enum",
    values: ["+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&="]
  };

  var BinaryOperator = {
    typeName: "Enum",
    values: ["==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<", ">>", ">>>", "+", "-", "*", "/", "%", ",", "||", "&&", "|", "^", "&"]
  };

  var UnaryOperator = {
    typeName: "Enum",
    values: ["+", "-", "!", "~", "typeof", "void", "delete"]
  };

  var UpdateOperator = {
    typeName: "Enum",
    values: ["++", "--"]
  };

  var SourceLocation = SPEC.SourceLocation = {};
  var SourceSpan = SPEC.SourceSpan = {};
  var BindingWithDefault = SPEC.BindingWithDefault = {};
  var BindingIdentifier = SPEC.BindingIdentifier = {};
  var ArrayBinding = SPEC.ArrayBinding = {};
  var ObjectBinding = SPEC.ObjectBinding = {};
  var BindingPropertyIdentifier = SPEC.BindingPropertyIdentifier = {};
  var BindingPropertyProperty = SPEC.BindingPropertyProperty = {};
  var ClassExpression = SPEC.ClassExpression = {};
  var ClassDeclaration = SPEC.ClassDeclaration = {};
  var ClassElement = SPEC.ClassElement = {};
  var Module = SPEC.Module = {};
  var Import = SPEC.Import = {};
  var ImportNamespace = SPEC.ImportNamespace = {};
  var ImportSpecifier = SPEC.ImportSpecifier = {};
  var ExportAllFrom = SPEC.ExportAllFrom = {};
  var ExportFrom = SPEC.ExportFrom = {};
  var Export = SPEC.Export = {};
  var ExportDefault = SPEC.ExportDefault = {};
  var ExportSpecifier = SPEC.ExportSpecifier = {};
  var Method = SPEC.Method = {};
  var Getter = SPEC.Getter = {};
  var Setter = SPEC.Setter = {};
  var DataProperty = SPEC.DataProperty = {};
  var ShorthandProperty = SPEC.ShorthandProperty = {};
  var ComputedPropertyName = SPEC.ComputedPropertyName = {};
  var StaticPropertyName = SPEC.StaticPropertyName = {};
  var LiteralBooleanExpression = SPEC.LiteralBooleanExpression = {};
  var LiteralInfinityExpression = SPEC.LiteralInfinityExpression = {};
  var LiteralNullExpression = SPEC.LiteralNullExpression = {};
  var LiteralNumericExpression = SPEC.LiteralNumericExpression = {};
  var LiteralRegExpExpression = SPEC.LiteralRegExpExpression = {};
  var LiteralStringExpression = SPEC.LiteralStringExpression = {};
  var ArrayExpression = SPEC.ArrayExpression = {};
  var ArrowExpression = SPEC.ArrowExpression = {};
  var AssignmentExpression = SPEC.AssignmentExpression = {};
  var BinaryExpression = SPEC.BinaryExpression = {};
  var CallExpression = SPEC.CallExpression = {};
  var CompoundAssignmentExpression = SPEC.CompoundAssignmentExpression = {};
  var ComputedMemberExpression = SPEC.ComputedMemberExpression = {};
  var ConditionalExpression = SPEC.ConditionalExpression = {};
  var FunctionExpression = SPEC.FunctionExpression = {};
  var IdentifierExpression = SPEC.IdentifierExpression = {};
  var NewExpression = SPEC.NewExpression = {};
  var NewTargetExpression = SPEC.NewTargetExpression = {};
  var ObjectExpression = SPEC.ObjectExpression = {};
  var UnaryExpression = SPEC.UnaryExpression = {};
  var StaticMemberExpression = SPEC.StaticMemberExpression = {};
  var TemplateExpression = SPEC.TemplateExpression = {};
  var ThisExpression = SPEC.ThisExpression = {};
  var UpdateExpression = SPEC.UpdateExpression = {};
  var YieldExpression = SPEC.YieldExpression = {};
  var YieldGeneratorExpression = SPEC.YieldGeneratorExpression = {};
  var BlockStatement = SPEC.BlockStatement = {};
  var BreakStatement = SPEC.BreakStatement = {};
  var ContinueStatement = SPEC.ContinueStatement = {};
  var DebuggerStatement = SPEC.DebuggerStatement = {};
  var DoWhileStatement = SPEC.DoWhileStatement = {};
  var EmptyStatement = SPEC.EmptyStatement = {};
  var ExpressionStatement = SPEC.ExpressionStatement = {};
  var ForInStatement = SPEC.ForInStatement = {};
  var ForOfStatement = SPEC.ForOfStatement = {};
  var ForStatement = SPEC.ForStatement = {};
  var IfStatement = SPEC.IfStatement = {};
  var LabeledStatement = SPEC.LabeledStatement = {};
  var ReturnStatement = SPEC.ReturnStatement = {};
  var SwitchStatement = SPEC.SwitchStatement = {};
  var SwitchStatementWithDefault = SPEC.SwitchStatementWithDefault = {};
  var ThrowStatement = SPEC.ThrowStatement = {};
  var TryCatchStatement = SPEC.TryCatchStatement = {};
  var TryFinallyStatement = SPEC.TryFinallyStatement = {};
  var VariableDeclarationStatement = SPEC.VariableDeclarationStatement = {};
  var WhileStatement = SPEC.WhileStatement = {};
  var WithStatement = SPEC.WithStatement = {};
  var Block = SPEC.Block = {};
  var CatchClause = SPEC.CatchClause = {};
  var Directive = SPEC.Directive = {};
  var FormalParameters = SPEC.FormalParameters = {};
  var FunctionBody = SPEC.FunctionBody = {};
  var FunctionDeclaration = SPEC.FunctionDeclaration = {};
  var Script = SPEC.Script = {};
  var SpreadElement = SPEC.SpreadElement = {};
  var Super = SPEC.Super = {};
  var SwitchCase = SPEC.SwitchCase = {};
  var SwitchDefault = SPEC.SwitchDefault = {};
  var TemplateElement = SPEC.TemplateElement = {};
  var VariableDeclaration = SPEC.VariableDeclaration = {};
  var VariableDeclarator = SPEC.VariableDeclarator = {};

  var Class = Union(ClassExpression, ClassDeclaration);
  var BindingProperty = Union(BindingPropertyIdentifier, BindingPropertyProperty);
  var ExportDeclaration = Union(ExportAllFrom, ExportFrom, Export, ExportDefault);
  var ImportDeclaration = Union(Import, ImportNamespace);
  var MethodDefinition = Union(Method, Getter, Setter);
  var NamedObjectProperty = Union(MethodDefinition, DataProperty);
  var ObjectProperty = Union(NamedObjectProperty, ShorthandProperty);
  var PropertyName = Union(ComputedPropertyName, StaticPropertyName);
  var MemberExpression = Union(ComputedMemberExpression, StaticMemberExpression);
  var Expression = Union(MemberExpression, ClassExpression, LiteralBooleanExpression, LiteralInfinityExpression, LiteralNullExpression, LiteralNumericExpression, LiteralRegExpExpression, LiteralStringExpression, ArrayExpression, ArrowExpression, AssignmentExpression, BinaryExpression, CallExpression, CompoundAssignmentExpression, ConditionalExpression, FunctionExpression, IdentifierExpression, NewExpression, NewTargetExpression, ObjectExpression, UnaryExpression, TemplateExpression, ThisExpression, UpdateExpression, YieldExpression, YieldGeneratorExpression);
  var IterationStatement = Union(DoWhileStatement, ForInStatement, ForOfStatement, ForStatement, WhileStatement);
  var Statement = Union(IterationStatement, ClassDeclaration, BlockStatement, BreakStatement, ContinueStatement, DebuggerStatement, EmptyStatement, ExpressionStatement, IfStatement, LabeledStatement, ReturnStatement, SwitchStatement, SwitchStatementWithDefault, ThrowStatement, TryCatchStatement, TryFinallyStatement, VariableDeclarationStatement, WithStatement, FunctionDeclaration);
  var Node = Union(Statement, Expression, PropertyName, ObjectProperty, ImportDeclaration, ExportDeclaration, BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding, BindingProperty, ClassElement, Module, ImportSpecifier, ExportSpecifier, Block, CatchClause, Directive, FormalParameters, FunctionBody, Script, SpreadElement, Super, SwitchCase, SwitchDefault, TemplateElement, VariableDeclaration, VariableDeclarator);
  var Function = Union(FunctionExpression, FunctionDeclaration);

  SourceLocation.typeName = "SourceLocation";
  SourceLocation.fields = [
    { name: "line", type: DOUBLE },
    { name: "column", type: DOUBLE },
    { name: "offset", type: DOUBLE },
  ];

  SourceSpan.typeName = "SourceSpan";
  SourceSpan.fields = [
    { name: "source", type: Maybe(STRING) },
    { name: "start", type: SourceLocation },
    { name: "end", type: SourceLocation },
  ];

  BindingWithDefault.typeName = "BindingWithDefault";
  BindingWithDefault.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingWithDefault" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
    { name: "init", type: Expression },
  ];

  BindingIdentifier.typeName = "BindingIdentifier";
  BindingIdentifier.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingIdentifier" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "name", type: STRING },
  ];

  ArrayBinding.typeName = "ArrayBinding";
  ArrayBinding.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrayBinding" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "elements", type: List(Maybe(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault))) },
    { name: "restElement", type: Maybe(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression)) },
  ];

  ObjectBinding.typeName = "ObjectBinding";
  ObjectBinding.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ObjectBinding" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "properties", type: List(BindingProperty) },
  ];

  BindingPropertyIdentifier.typeName = "BindingPropertyIdentifier";
  BindingPropertyIdentifier.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingPropertyIdentifier" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "binding", type: BindingIdentifier },
    { name: "init", type: Maybe(Expression) },
  ];

  BindingPropertyProperty.typeName = "BindingPropertyProperty";
  BindingPropertyProperty.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingPropertyProperty" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "name", type: PropertyName },
    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault) },
  ];

  ClassExpression.typeName = "ClassExpression";
  ClassExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "name", type: Maybe(BindingIdentifier) },
    { name: "super", type: Maybe(Expression) },
    { name: "elements", type: List(ClassElement) },
  ];

  ClassDeclaration.typeName = "ClassDeclaration";
  ClassDeclaration.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassDeclaration" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "name", type: BindingIdentifier },
    { name: "super", type: Maybe(Expression) },
    { name: "elements", type: List(ClassElement) },
  ];

  ClassElement.typeName = "ClassElement";
  ClassElement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassElement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "isStatic", type: BOOLEAN },
    { name: "method", type: MethodDefinition },
  ];

  Module.typeName = "Module";
  Module.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Module" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "directives", type: List(Directive) },
    { name: "items", type: List(Union(ImportDeclaration, ExportDeclaration, Statement)) },
  ];

  Import.typeName = "Import";
  Import.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Import" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "moduleSpecifier", type: STRING },
    { name: "defaultBinding", type: Maybe(BindingIdentifier) },
    { name: "namedImports", type: List(ImportSpecifier) },
  ];

  ImportNamespace.typeName = "ImportNamespace";
  ImportNamespace.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ImportNamespace" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "moduleSpecifier", type: STRING },
    { name: "defaultBinding", type: Maybe(BindingIdentifier) },
    { name: "namespaceBinding", type: BindingIdentifier },
  ];

  ImportSpecifier.typeName = "ImportSpecifier";
  ImportSpecifier.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ImportSpecifier" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "name", type: Maybe(STRING) },
    { name: "binding", type: BindingIdentifier },
  ];

  ExportAllFrom.typeName = "ExportAllFrom";
  ExportAllFrom.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportAllFrom" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "moduleSpecifier", type: STRING },
  ];

  ExportFrom.typeName = "ExportFrom";
  ExportFrom.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportFrom" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "namedExports", type: List(ExportSpecifier) },
    { name: "moduleSpecifier", type: Maybe(STRING) },
  ];

  Export.typeName = "Export";
  Export.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Export" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "declaration", type: Union(FunctionDeclaration, ClassDeclaration, VariableDeclaration) },
  ];

  ExportDefault.typeName = "ExportDefault";
  ExportDefault.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportDefault" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "body", type: Union(FunctionDeclaration, ClassDeclaration, Expression) },
  ];

  ExportSpecifier.typeName = "ExportSpecifier";
  ExportSpecifier.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportSpecifier" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "name", type: Maybe(STRING) },
    { name: "exportedName", type: STRING },
  ];

  Method.typeName = "Method";
  Method.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Method" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "name", type: PropertyName },
    { name: "isGenerator", type: BOOLEAN },
    { name: "params", type: FormalParameters },
    { name: "body", type: FunctionBody },
  ];

  Getter.typeName = "Getter";
  Getter.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Getter" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "name", type: PropertyName },
    { name: "body", type: FunctionBody },
  ];

  Setter.typeName = "Setter";
  Setter.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Setter" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "name", type: PropertyName },
    { name: "param", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault) },
    { name: "body", type: FunctionBody },
  ];

  DataProperty.typeName = "DataProperty";
  DataProperty.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "DataProperty" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "name", type: PropertyName },
    { name: "expression", type: Expression },
  ];

  ShorthandProperty.typeName = "ShorthandProperty";
  ShorthandProperty.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ShorthandProperty" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "name", type: STRING },
  ];

  ComputedPropertyName.typeName = "ComputedPropertyName";
  ComputedPropertyName.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ComputedPropertyName" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "expression", type: Expression },
  ];

  StaticPropertyName.typeName = "StaticPropertyName";
  StaticPropertyName.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "StaticPropertyName" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "value", type: STRING },
  ];

  LiteralBooleanExpression.typeName = "LiteralBooleanExpression";
  LiteralBooleanExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralBooleanExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "value", type: BOOLEAN },
  ];

  LiteralInfinityExpression.typeName = "LiteralInfinityExpression";
  LiteralInfinityExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralInfinityExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
  ];

  LiteralNullExpression.typeName = "LiteralNullExpression";
  LiteralNullExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralNullExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
  ];

  LiteralNumericExpression.typeName = "LiteralNumericExpression";
  LiteralNumericExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralNumericExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "value", type: DOUBLE },
  ];

  LiteralRegExpExpression.typeName = "LiteralRegExpExpression";
  LiteralRegExpExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralRegExpExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "pattern", type: STRING },
    { name: "flags", type: STRING },
  ];

  LiteralStringExpression.typeName = "LiteralStringExpression";
  LiteralStringExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralStringExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "value", type: STRING },
  ];

  ArrayExpression.typeName = "ArrayExpression";
  ArrayExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrayExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "elements", type: List(Maybe(Union(SpreadElement, Expression))) },
  ];

  ArrowExpression.typeName = "ArrowExpression";
  ArrowExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrowExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "params", type: FormalParameters },
    { name: "body", type: Union(FunctionBody, Expression) },
  ];

  AssignmentExpression.typeName = "AssignmentExpression";
  AssignmentExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "AssignmentExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
    { name: "expression", type: Expression },
  ];

  BinaryExpression.typeName = "BinaryExpression";
  BinaryExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "BinaryExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "operator", type: BinaryOperator },
    { name: "left", type: Expression },
    { name: "right", type: Expression },
  ];

  CallExpression.typeName = "CallExpression";
  CallExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "CallExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "callee", type: Union(Expression, Super) },
    { name: "arguments", type: List(Union(SpreadElement, Expression)) },
  ];

  CompoundAssignmentExpression.typeName = "CompoundAssignmentExpression";
  CompoundAssignmentExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "CompoundAssignmentExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "operator", type: CompoundAssignmentOperator },
    { name: "binding", type: Union(BindingIdentifier, MemberExpression) },
    { name: "expression", type: Expression },
  ];

  ComputedMemberExpression.typeName = "ComputedMemberExpression";
  ComputedMemberExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ComputedMemberExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "object", type: Union(Expression, Super) },
    { name: "expression", type: Expression },
  ];

  ConditionalExpression.typeName = "ConditionalExpression";
  ConditionalExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ConditionalExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "test", type: Expression },
    { name: "consequent", type: Expression },
    { name: "alternate", type: Expression },
  ];

  FunctionExpression.typeName = "FunctionExpression";
  FunctionExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "isGenerator", type: BOOLEAN },
    { name: "name", type: Maybe(BindingIdentifier) },
    { name: "params", type: FormalParameters },
    { name: "body", type: FunctionBody },
  ];

  IdentifierExpression.typeName = "IdentifierExpression";
  IdentifierExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "IdentifierExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "name", type: STRING },
  ];

  NewExpression.typeName = "NewExpression";
  NewExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "NewExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "callee", type: Expression },
    { name: "arguments", type: List(Union(SpreadElement, Expression)) },
  ];

  NewTargetExpression.typeName = "NewTargetExpression";
  NewTargetExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "NewTargetExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
  ];

  ObjectExpression.typeName = "ObjectExpression";
  ObjectExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ObjectExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "properties", type: List(ObjectProperty) },
  ];

  UnaryExpression.typeName = "UnaryExpression";
  UnaryExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "UnaryExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "operator", type: UnaryOperator },
    { name: "operand", type: Expression },
  ];

  StaticMemberExpression.typeName = "StaticMemberExpression";
  StaticMemberExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "StaticMemberExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "object", type: Union(Expression, Super) },
    { name: "property", type: STRING },
  ];

  TemplateExpression.typeName = "TemplateExpression";
  TemplateExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "TemplateExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "tag", type: Maybe(Expression) },
    { name: "elements", type: List(Union(Expression, TemplateElement)) },
  ];

  ThisExpression.typeName = "ThisExpression";
  ThisExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ThisExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
  ];

  UpdateExpression.typeName = "UpdateExpression";
  UpdateExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "UpdateExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "isPrefix", type: BOOLEAN },
    { name: "operator", type: UpdateOperator },
    { name: "operand", type: Union(BindingIdentifier, MemberExpression) },
  ];

  YieldExpression.typeName = "YieldExpression";
  YieldExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "YieldExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "expression", type: Maybe(Expression) },
  ];

  YieldGeneratorExpression.typeName = "YieldGeneratorExpression";
  YieldGeneratorExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "YieldGeneratorExpression" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "expression", type: Expression },
  ];

  BlockStatement.typeName = "BlockStatement";
  BlockStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "BlockStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "block", type: Block },
  ];

  BreakStatement.typeName = "BreakStatement";
  BreakStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "BreakStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "label", type: Maybe(STRING) },
  ];

  ContinueStatement.typeName = "ContinueStatement";
  ContinueStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ContinueStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "label", type: Maybe(STRING) },
  ];

  DebuggerStatement.typeName = "DebuggerStatement";
  DebuggerStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "DebuggerStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
  ];

  DoWhileStatement.typeName = "DoWhileStatement";
  DoWhileStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "DoWhileStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "body", type: Statement },
    { name: "test", type: Expression },
  ];

  EmptyStatement.typeName = "EmptyStatement";
  EmptyStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "EmptyStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
  ];

  ExpressionStatement.typeName = "ExpressionStatement";
  ExpressionStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ExpressionStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "expression", type: Expression },
  ];

  ForInStatement.typeName = "ForInStatement";
  ForInStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ForInStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "left", type: Union(VariableDeclaration, ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
    { name: "right", type: Expression },
    { name: "body", type: Statement },
  ];

  ForOfStatement.typeName = "ForOfStatement";
  ForOfStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ForOfStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "left", type: Union(VariableDeclaration, ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
    { name: "right", type: Expression },
    { name: "body", type: Statement },
  ];

  ForStatement.typeName = "ForStatement";
  ForStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ForStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "init", type: Maybe(Union(VariableDeclaration, Expression)) },
    { name: "test", type: Maybe(Expression) },
    { name: "update", type: Maybe(Expression) },
    { name: "body", type: Statement },
  ];

  IfStatement.typeName = "IfStatement";
  IfStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "IfStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "test", type: Expression },
    { name: "consequent", type: Statement },
    { name: "alternate", type: Maybe(Statement) },
  ];

  LabeledStatement.typeName = "LabeledStatement";
  LabeledStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "LabeledStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "label", type: STRING },
    { name: "body", type: Statement },
  ];

  ReturnStatement.typeName = "ReturnStatement";
  ReturnStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ReturnStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "expression", type: Maybe(Expression) },
  ];

  SwitchStatement.typeName = "SwitchStatement";
  SwitchStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "discriminant", type: Expression },
    { name: "cases", type: List(SwitchCase) },
  ];

  SwitchStatementWithDefault.typeName = "SwitchStatementWithDefault";
  SwitchStatementWithDefault.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchStatementWithDefault" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "discriminant", type: Expression },
    { name: "preDefaultCases", type: List(SwitchCase) },
    { name: "defaultCase", type: SwitchDefault },
    { name: "postDefaultCases", type: List(SwitchCase) },
  ];

  ThrowStatement.typeName = "ThrowStatement";
  ThrowStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ThrowStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "expression", type: Expression },
  ];

  TryCatchStatement.typeName = "TryCatchStatement";
  TryCatchStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "TryCatchStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "body", type: Block },
    { name: "catchClause", type: CatchClause },
  ];

  TryFinallyStatement.typeName = "TryFinallyStatement";
  TryFinallyStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "TryFinallyStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "body", type: Block },
    { name: "catchClause", type: Maybe(CatchClause) },
    { name: "finalizer", type: Block },
  ];

  VariableDeclarationStatement.typeName = "VariableDeclarationStatement";
  VariableDeclarationStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclarationStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "declaration", type: VariableDeclaration },
  ];

  WhileStatement.typeName = "WhileStatement";
  WhileStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "WhileStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "test", type: Expression },
    { name: "body", type: Statement },
  ];

  WithStatement.typeName = "WithStatement";
  WithStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "WithStatement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "object", type: Expression },
    { name: "body", type: Statement },
  ];

  Block.typeName = "Block";
  Block.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Block" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "statements", type: List(Statement) },
  ];

  CatchClause.typeName = "CatchClause";
  CatchClause.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "CatchClause" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
    { name: "body", type: Block },
  ];

  Directive.typeName = "Directive";
  Directive.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Directive" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "rawValue", type: STRING },
  ];

  FormalParameters.typeName = "FormalParameters";
  FormalParameters.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "FormalParameters" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "items", type: List(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault)) },
    { name: "rest", type: Maybe(BindingIdentifier) },
  ];

  FunctionBody.typeName = "FunctionBody";
  FunctionBody.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionBody" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "directives", type: List(Directive) },
    { name: "statements", type: List(Statement) },
  ];

  FunctionDeclaration.typeName = "FunctionDeclaration";
  FunctionDeclaration.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionDeclaration" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "isGenerator", type: BOOLEAN },
    { name: "name", type: BindingIdentifier },
    { name: "params", type: FormalParameters },
    { name: "body", type: FunctionBody },
  ];

  Script.typeName = "Script";
  Script.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Script" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "directives", type: List(Directive) },
    { name: "statements", type: List(Statement) },
  ];

  SpreadElement.typeName = "SpreadElement";
  SpreadElement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "SpreadElement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "expression", type: Expression },
  ];

  Super.typeName = "Super";
  Super.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Super" },
    { name: "loc", type: Maybe(SourceSpan) },
  ];

  SwitchCase.typeName = "SwitchCase";
  SwitchCase.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchCase" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "test", type: Expression },
    { name: "consequent", type: List(Statement) },
  ];

  SwitchDefault.typeName = "SwitchDefault";
  SwitchDefault.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchDefault" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "consequent", type: List(Statement) },
  ];

  TemplateElement.typeName = "TemplateElement";
  TemplateElement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "TemplateElement" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "rawValue", type: STRING },
  ];

  VariableDeclaration.typeName = "VariableDeclaration";
  VariableDeclaration.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclaration" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "kind", type: VariableDeclarationKind },
    { name: "declarators", type: List(VariableDeclarator) },
  ];

  VariableDeclarator.typeName = "VariableDeclarator";
  VariableDeclarator.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclarator" },
    { name: "loc", type: Maybe(SourceSpan) },
    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
    { name: "init", type: Maybe(Expression) },
  ];

  return SPEC;
}());
