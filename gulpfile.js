// Generated by LiveScript 1.5.0
(function(){
  var livescript, gulp, gulpChanged, gulpUtil, gulpPrint, gulpLivescript, gulpYaml, gulpEslint, gulpHeader, path, fs, vinylNamed, webpack, gulpVulcanize, gulpCrisper, del, deepcopy, jsYaml, mkdirp, glob, bestzip, chromeWebStoreItemProperty, livereload, semver, deepmerge, is_debug_build, BabiliPlugin, UglifyJsPlugin, HabitLabComponentRenamePlugin, HabitLabComponentListPlugin, fse, webpackStream, prelude, gen_deps, function_signatures, webpack_config_frontend, webpack_config_backend, lspattern, lspattern_srcgen, enabled_intervention_list, yamlpattern_manifest, yamlpattern_base, yamlpattern, eslintpattern, jspattern_srcgen, htmlpattern_srcgen, intervention_copypattern, copypattern, copyrootpattern, webpack_pattern, webpack_pattern_content_scripts, webpack_vulcanize_pattern, vulcanize_html_pattern, vulcanize_html_output_pattern, vulcanize_watch_pattern, eslint_config, empty_or_updated, fromcwd, run_gulp_webpack, with_created_object, webpack_config_watch, webpack_config_nowatch, webpack_config_watch_content_scripts, webpack_config_nowatch_content_scripts, webpack_config_nowatch_content_scripts_listcomponents, webpack_config_nosrcmap_watch, webpack_config_nosrcmap_nowatch, webpack_config_prod_nowatch, webpack_config_prod_nowatch_content_scripts, copy_file_patterns, copy_file_pattern, extra_folders, mkzip_function, get_latest_published_version, slice$ = [].slice;
  livescript = require('livescript');
  gulp = require('gulp');
  gulpChanged = require('gulp-changed');
  gulpUtil = require('gulp-util');
  gulpPrint = require('gulp-print');
  gulpLivescript = require('gulp-livescript-async');
  gulpYaml = require('gulp-yaml');
  gulpEslint = require('gulp-eslint');
  gulpHeader = require('gulp-header');
  path = require('path');
  fs = require('fs');
  vinylNamed = require('vinyl-named');
  webpack = require('webpack');
  gulpVulcanize = require('gulp-vulcanize');
  gulpCrisper = require('gulp-crisper');
  del = require('del');
  deepcopy = require('deepcopy');
  jsYaml = require('js-yaml');
  mkdirp = require('mkdirp');
  glob = require('glob');
  bestzip = require('bestzip');
  chromeWebStoreItemProperty = require('chrome-web-store-item-property');
  livereload = require('livereload');
  semver = require('semver');
  deepmerge = require('deepmerge');
  is_debug_build = false;
  BabiliPlugin = require('babel-minify-webpack-plugin');
  UglifyJsPlugin = require('uglifyjs-webpack-plugin');
  HabitLabComponentRenamePlugin = require('./webpack_habitlab_component_rename_plugin');
  HabitLabComponentListPlugin = require('./webpack_habitlab_component_list_plugin');
  fse = require('fs-extra');
  webpackStream = require('webpack4-stream-watch');
  process.on('unhandledRejection', function(reason, p){
    throw new Error(reason);
  });
  prelude = require('prelude-ls');
  gen_deps = require('./scripts/generate_polymer_dependencies_lib.ls');
  function_signatures = require('./src/libs_common/function_signatures.ls');
  webpack_config_frontend = require('./webpack_config_frontend.ls');
  webpack_config_backend = require('./webpack_config_backend.ls');
  lspattern = ['src/redirect.ls', 'src/habitlab_website_redirect.ls', 'src/components/*.ls', 'src/fields/*.ls', 'src/libs_frontend/**/*.ls', 'src/libs_common/**/*.ls', 'src/libs_backend/**/*.ls', 'src/goals/**/*.ls'];
  lspattern_srcgen = ['src/**/*.ls'];
  enabled_intervention_list = [];
  (function(){
    var i$, ref$, len$, info_yaml_filepath, info_yaml_data, basepath, basepath_parts, results$ = [];
    for (i$ = 0, len$ = (ref$ = glob.sync('src/interventions/**/*.yaml')).length; i$ < len$; ++i$) {
      info_yaml_filepath = ref$[i$];
      info_yaml_data = jsYaml.safeLoad(fs.readFileSync(info_yaml_filepath));
      if (info_yaml_data == null) {
        console.log('syntax error in yaml file: ' + info_yaml_filepath);
      }
      if (info_yaml_data.description == null) {
        console.log('missing description: ' + info_yaml_filepath);
        continue;
      }
      if (info_yaml_data.disabled) {
        console.log('intervention disabled: ' + info_yaml_filepath);
        continue;
      }
      basepath = info_yaml_filepath.substr(0, info_yaml_filepath.length - 10);
      basepath_parts = basepath.split('/');
      basepath = slice$.call(basepath_parts, basepath_parts.length - 2).join('/');
      results$.push(enabled_intervention_list.push(basepath));
    }
    return results$;
  })();
  yamlpattern_manifest = ['src/manifest.yaml', 'src/manifest_extra.yaml'];
  yamlpattern_base = ['src/goals/**/*.yaml', 'src/fields/**/*.yaml'];
  (function(){
    var i$, ref$, len$, enabled_intervention_name, results$ = [];
    for (i$ = 0, len$ = (ref$ = enabled_intervention_list).length; i$ < len$; ++i$) {
      enabled_intervention_name = ref$[i$];
      results$.push(yamlpattern_base.push('src/interventions/' + enabled_intervention_name + '/*.yaml'));
    }
    return results$;
  })();
  yamlpattern = yamlpattern_manifest.concat(yamlpattern_base);
  eslintpattern = ['src/**/*.js', 'src_gen/**/*.js', '!src/flowtypes/*.js', '!src/bundles/*.js', '!src_gen/bundles/*.js', '!src/bugmuncher/*.js', '!src_gen/bugmuncher/*.js', '!src/bower_components/**/*.js', '!src_gen/bower_components/**/*.js', '!src/**/*.deps.js', '!src/**/*.jspm.js', '!src/jspm_packages/**/*.js', '!src_gen/jspm_packages/**/*.js', '!src/modules_custom/**/*.js', '!src_gen/modules_custom/**/*.js'];
  jspattern_srcgen = ['src/**/*.js', '!src/flowtypes/*.js', '!src/**/*.deps.js'];
  htmlpattern_srcgen = ['src/**/*.html'];
  intervention_copypattern = [];
  (function(){
    var i$, ref$, len$, enabled_intervention_name, results$ = [];
    for (i$ = 0, len$ = (ref$ = enabled_intervention_list).length; i$ < len$; ++i$) {
      enabled_intervention_name = ref$[i$];
      intervention_copypattern.push('src_gen/interventions/' + enabled_intervention_name + '/**/*.js');
      results$.push(intervention_copypattern.push('src_gen/interventions/' + enabled_intervention_name + '/*.js'));
    }
    return results$;
  })();
  copypattern = ['src/**/*.html', 'src/**/*.png', 'src/**/*.jpg', 'src/**/*.gif', 'src/**/*.svg', 'src/*.json', 'src/*.js', 'src/*.css', 'src/_locales/**/*', 'src/bugmuncher/*', 'src/bundles/*', 'src/libs_common/*.js', 'src/libs_backend/*.js', 'src/libs_frontend/*.js', 'src/goals/**/*.js', 'src/generated_libs/**/*.js', 'src/bower_components/**/*', 'src/components/**/*.js', 'src/modules_custom/**/*.js', 'src/modules_custom/**/*.css', '!src/**/*.deps.js', '!src/**/*.jspm.js', '!src/jspm_packages/**/*'];
  (function(){
    var i$, ref$, len$, src_subfolder, j$, ref1$, len1$, extension, enabled_intervention_name, lresult$, results$ = [];
    for (i$ = 0, len$ = (ref$ = ['goals', 'modules_custom', 'components']).length; i$ < len$; ++i$) {
      src_subfolder = ref$[i$];
      for (j$ = 0, len1$ = (ref1$ = ['html', 'png', 'jpg', 'gif', 'svg']).length; j$ < len1$; ++j$) {
        extension = ref1$[j$];
        copypattern.push('src/' + src_subfolder + '/**/*.' + extension);
      }
    }
    for (i$ = 0, len$ = (ref$ = enabled_intervention_list).length; i$ < len$; ++i$) {
      enabled_intervention_name = ref$[i$];
      lresult$ = [];
      for (j$ = 0, len1$ = (ref1$ = ['html', 'png', 'jpg', 'gif', 'svg']).length; j$ < len1$; ++j$) {
        extension = ref1$[j$];
        copypattern.push('src/interventions/' + enabled_intervention_name + '/*.' + extension);
        lresult$.push(copypattern.push('src/interventions/' + enabled_intervention_name + '/**/*.' + extension));
      }
      results$.push(lresult$);
    }
    return results$;
  })();
  copyrootpattern = ['jspm.config.js', 'jspm_config_frontend.js', 'jspm_config_backend.js'];
  webpack_pattern = ['src/backend/background.ls', 'src/index.ls', 'src/index_jspm.ls', 'src/options.ls', 'src/popup.ls', 'src/index_loader.js'];
  webpack_pattern_content_scripts = ['src/intervention_utils/**/*.ls', 'src/intervention_utils/**/*.js', 'src/frontend_utils/**/*.ls', 'src/frontend_utils/**/*.js', 'src/frontend_utils/*.ls', 'src/frontend_utils/*.js', '!src/**/*.deps.js', '!src/**/*.jspm.js'];
  (function(){
    var i$, ref$, len$, enabled_intervention_name, results$ = [];
    for (i$ = 0, len$ = (ref$ = enabled_intervention_list).length; i$ < len$; ++i$) {
      enabled_intervention_name = ref$[i$];
      webpack_pattern_content_scripts.push('src/interventions/' + enabled_intervention_name + '/*.ls');
      results$.push(webpack_pattern_content_scripts.push('src/interventions/' + enabled_intervention_name + '/*.js'));
    }
    return results$;
  })();
  webpack_vulcanize_pattern = ['src_vulcanize/components/components.js'];
  vulcanize_html_pattern = ['src_gen/components/components.html'];
  vulcanize_html_output_pattern = ['src_vulcanize/components/components.html'];
  vulcanize_watch_pattern = ['src/components/**/*.html', 'src/components/**/*.js', 'src/components/**/*.ls', '!src/**/*.deps.js', '!src/**/*.jspm.js'];
  eslint_config = jsYaml.safeLoad(fs.readFileSync('.eslintrc.yaml', 'utf-8'));
  eslint_config.globals = Object.keys(eslint_config.globals);
  gulp.task('livescript_srcgen', function(){
    return gulp.src(lspattern_srcgen, {
      base: 'src'
    }).pipe(gulpChanged('src_gen', {
      extension: '.js'
    })).pipe(gulpLivescript({
      bare: true
    })).pipe(gulpHeader('/* livescript */\n\n')).on('error', gulpUtil.log).pipe(gulp.dest('src_gen'));
  });
  gulp.task('js_srcgen', function(){
    return gulp.src(jspattern_srcgen, {
      base: 'src'
    }).pipe(gulpChanged('src_gen')).pipe(gulp.dest('src_gen'));
  });
  gulp.task('eslint', gulp.series(gulp.parallel('livescript_srcgen', 'js_srcgen'), function(){
    return gulp.src(eslintpattern, {
      base: 'src'
    }).pipe(gulpEslint(eslint_config)).pipe(gulpEslint.formatEach('compact', process.stderr));
  }));
  gulp.task('livescript_build', function(){
    return gulp.src(lspattern, {
      base: 'src'
    }).pipe(gulpChanged('dist', {
      extension: '.js'
    })).pipe(gulpPrint(function(it){
      return "livescript: " + it;
    })).pipe(gulpLivescript({
      bare: false
    })).on('error', gulpUtil.log).pipe(gulp.dest('dist'));
  });
  empty_or_updated = function(stream, cb, sourceFile, targetPath){
    if (!fs.existsSync(targetPath)) {
      stream.push(sourceFile);
      return cb();
    }
    if (fs.statSync(targetPath).size === 0) {
      stream.push(sourceFile);
      return cb();
    }
    return gulpChanged.compareLastModifiedTime(stream, cb, sourceFile, targetPath);
  };
  fromcwd = function(x){
    return path.join(process.cwd(), x);
  };
  run_gulp_webpack = function(myconfig, options){
    var src_pattern, src_base, current_dir;
    options == null && (options = {});
    src_pattern = options.src_pattern, src_base = options.src_base;
    src_pattern == null && (src_pattern = webpack_pattern);
    src_base == null && (src_base = 'src');
    current_dir = process.cwd();
    return gulp.src(src_pattern, {
      base: src_base
    }).pipe(gulpPrint(function(it){
      return "webpack: " + it;
    })).pipe(vinylNamed(function(file){
      var relative_path, relative_path_noext;
      relative_path = path.relative(path.join(current_dir, src_base), file.path);
      relative_path_noext = relative_path.replace(/\.jsx$/, '').replace(/\.js$/, '').replace(/\.ls$/, '');
      return relative_path_noext;
    })).pipe(webpackStream(myconfig)).on('error', function(err){
      gulpUtil.log(err.message);
      return this.emit('end');
    }).pipe(gulp.dest('dist'));
  };
  with_created_object = function(orig_obj, func_to_apply){
    var new_obj;
    new_obj = deepcopy(orig_obj);
    func_to_apply(new_obj);
    return new_obj;
  };
  webpack_config_watch = with_created_object(webpack_config_backend, function(o){
    o.watch = true;
    return o.devtool = false;
  });
  webpack_config_nowatch = with_created_object(webpack_config_backend, function(o){
    o.watch = false;
    return o.devtool = false;
  });
  webpack_config_watch_content_scripts = with_created_object(webpack_config_frontend, function(o){
    o.watch = true;
    o.devtool = false;
    return o.plugins.push(new HabitLabComponentRenamePlugin());
  });
  webpack_config_nowatch_content_scripts = with_created_object(webpack_config_frontend, function(o){
    o.watch = false;
    o.devtool = false;
    return o.plugins.push(new HabitLabComponentRenamePlugin());
  });
  webpack_config_nowatch_content_scripts_listcomponents = with_created_object(webpack_config_frontend, function(o){
    o.watch = false;
    o.devtool = false;
    return o.plugins.push(new HabitLabComponentListPlugin());
  });
  webpack_config_nosrcmap_watch = with_created_object(webpack_config_backend, function(o){
    o.watch = true;
    return o.devtool = false;
  });
  webpack_config_nosrcmap_nowatch = with_created_object(webpack_config_backend, function(o){
    o.watch = false;
    return o.devtool = false;
  });
  webpack_config_prod_nowatch = with_created_object(webpack_config_backend, function(o){
    o.watch = false;
    o.devtool = false;
    o.plugins.push(new webpack.LoaderOptionsPlugin({
      debug: false
    }));
    return o.plugins.push(new UglifyJsPlugin({
      uglifyOptions: {
        ie8: false,
        ecma: 8,
        output: {
          comments: false,
          beautify: false
        }
      }
    }));
  });
  webpack_config_prod_nowatch_content_scripts = with_created_object(webpack_config_frontend, function(o){
    o.watch = false;
    o.devtool = false;
    o.plugins.push(new webpack.LoaderOptionsPlugin({
      debug: false
    }));
    o.plugins.push(new HabitLabComponentRenamePlugin());
    return o.plugins.push(new UglifyJsPlugin({
      uglifyOptions: {
        ie8: false,
        ecma: 8,
        output: {
          comments: false,
          beautify: false
        }
      }
    }));
  });
  gulp.task('webpack_vulcanize', function(){
    return run_gulp_webpack(webpack_config_nosrcmap_nowatch, {
      src_pattern: webpack_vulcanize_pattern,
      src_base: 'src_vulcanize'
    });
  });
  gulp.task('webpack_vulcanize_watch', function(){
    return run_gulp_webpack(webpack_config_nosrcmap_watch, {
      src_pattern: webpack_vulcanize_pattern,
      src_base: 'src_vulcanize'
    });
  });
  gulp.task('webpack_vulcanize_prod', function(){
    return run_gulp_webpack(webpack_config_prod_nowatch, {
      src_pattern: webpack_vulcanize_pattern,
      src_base: 'src_vulcanize'
    });
  });
  gulp.task('yaml_build_base', function(){
    return gulp.src(yamlpattern_base, {
      base: 'src'
    }).pipe(gulpChanged('dist', {
      extension: '.json'
    })).pipe(gulpPrint(function(it){
      return "yaml: " + it;
    })).pipe(gulpYaml({
      space: 2
    })).on('error', gulpUtil.log).pipe(gulp.dest('dist'));
  });
  gulp.task('yaml_build_manifest', function(done){
    var manifest_file_contents, manifest_file_extra;
    manifest_file_contents = jsYaml.safeLoad(fs.readFileSync('src/manifest.yaml'));
    if (is_debug_build) {
      manifest_file_contents.devtools_page = 'devtools.html';
    }
    if (fs.existsSync('src/manifest_extra.yaml')) {
      manifest_file_extra = jsYaml.safeLoad(fs.readFileSync('src/manifest_extra.yaml'));
      manifest_file_contents = deepmerge(manifest_file_contents, manifest_file_extra);
    }
    fs.writeFileSync('dist/manifest.json', JSON.stringify(manifest_file_contents, null, 2));
    return done();
  });
  gulp.task('yaml_build', gulp.parallel('yaml_build_base', 'yaml_build_manifest'));
  gulp.task('copy_interventions', gulp.series(gulp.parallel('livescript_srcgen', 'js_srcgen'), function(){
    return gulp.src(intervention_copypattern, {
      root: 'src_gen/interventions'
    }).pipe(gulpChanged('dist/intervention_templates')).pipe(gulp.dest('dist/intervention_templates'));
  }));
  gulp.task('copy_build', function(){
    return gulp.src(copypattern, {
      base: 'src'
    }).pipe(gulpChanged('dist')).pipe(gulp.dest('dist'));
  });
  gulp.task('copy_root_build', function(){
    return gulp.src(copyrootpattern, {
      base: ''
    }).pipe(gulpChanged('dist')).pipe(gulp.dest('dist'));
  });
  gulp.task('generate_polymer_dependencies', function(done){
    gen_deps.set_src_path(path.join(process.cwd(), 'src'));
    gen_deps.set_options();
    gen_deps.generate_dependencies_for_all_files_in_src_path();
    copy_file_pattern('bower_components/**/*.deps.js', false);
    copy_file_pattern('components/**/*.deps.js', true);
    return done();
  });
  copy_file_patterns = function(patterns, overwrite){
    var i$, len$, pattern;
    if (overwrite == null) {
      overwrite = false;
    }
    for (i$ = 0, len$ = patterns.length; i$ < len$; ++i$) {
      pattern = patterns[i$];
      copy_file_pattern(pattern, overwrite);
    }
  };
  copy_file_pattern = function(pattern, overwrite){
    var files_list, existing_files_list, existing_files, res$, i$, len$, x, src_file, dist_file;
    if (overwrite == null) {
      overwrite = false;
    }
    files_list = glob.sync(path.join('src', pattern));
    existing_files_list = glob.sync(path.join('dist', pattern));
    res$ = {};
    for (i$ = 0, len$ = existing_files_list.length; i$ < len$; ++i$) {
      x = existing_files_list[i$];
      res$[x] = true;
    }
    existing_files = res$;
    for (i$ = 0, len$ = files_list.length; i$ < len$; ++i$) {
      src_file = files_list[i$];
      dist_file = src_file.replace(/^src\//, 'dist/');
      if (!overwrite) {
        if (existing_files[dist_file] != null) {
          continue;
        }
      }
      fse.copySync(src_file, dist_file);
    }
  };
  gulp.task('generate_polymer_dependencies_jspm', function(done){
    gen_deps.set_src_path(path.join(process.cwd(), 'src'));
    gen_deps.set_options({
      target_jspm: true
    });
    gen_deps.generate_dependencies_for_all_files_in_src_path();
    copy_file_pattern('bower_components/**/*.jspm.js', false);
    copy_file_pattern('components/**/*.jspm.js', true);
    return done();
  });
  gulp.task('generate_interventions_list', function(done){
    var output, i$, ref$, len$, info_yaml_filepath, intervention_info, intervention_name;
    mkdirp.sync('dist/interventions');
    output = [];
    for (i$ = 0, len$ = (ref$ = glob.sync('src/interventions/**/info.yaml')).length; i$ < len$; ++i$) {
      info_yaml_filepath = ref$[i$];
      intervention_info = jsYaml.safeLoad(fs.readFileSync(info_yaml_filepath, 'utf-8'));
      if (intervention_info == null) {
        console.log("no intervention_info for intervention " + info_yaml_filepath);
        continue;
      }
      if (intervention_info.disabled) {
        continue;
      }
      intervention_name = info_yaml_filepath.replace(/^src\/interventions\//, '').replace(/\/info\.yaml$/, '');
      output.push(intervention_name);
    }
    fs.writeFileSync('dist/interventions/interventions.json', JSON.stringify(prelude.sort(output)));
    return done();
  });
  gulp.task('generate_goals_list', function(done){
    var output, i$, ref$, len$, info_yaml_filepath, goal_info, goal_name;
    mkdirp.sync('dist/goals');
    output = [];
    for (i$ = 0, len$ = (ref$ = glob.sync('src/goals/**/info.yaml')).length; i$ < len$; ++i$) {
      info_yaml_filepath = ref$[i$];
      goal_info = jsYaml.safeLoad(fs.readFileSync(info_yaml_filepath, 'utf-8'));
      if (goal_info == null) {
        console.log("no goal_info for goal " + info_yaml_filepath);
        continue;
      }
      if (goal_info.disabled) {
        continue;
      }
      goal_name = info_yaml_filepath.replace(/^src\/goals\//, '').replace(/\/info\.yaml$/, '');
      output.push(goal_name);
    }
    output.push('debug/all_interventions');
    fs.writeFileSync('dist/goals/goals.json', JSON.stringify(prelude.sort(output)));
    return done();
  });
  gulp.task('generate_goal_intervention_info', function(done){
    var interventions, goals, output, intervention_name_to_info, i$, ref$, len$, info_yaml_filepath, intervention_info, intervention_name, goal_name_to_info, goal_info, goal_name, interventions_for_goal_new, generic_intervention_categories, generic_intervention_name_to_specific_name, j$, ref1$, len1$, k$, len2$, generic_intervention_category, generic_intervention_category_with_slash, generic_intervention, make_absolute_path, generic_name, is_default;
    interventions = [];
    goals = [];
    output = {
      interventions: interventions,
      goals: goals
    };
    intervention_name_to_info = {};
    for (i$ = 0, len$ = (ref$ = glob.sync('src/interventions/**/info.yaml')).length; i$ < len$; ++i$) {
      info_yaml_filepath = ref$[i$];
      intervention_info = jsYaml.safeLoad(fs.readFileSync(info_yaml_filepath, 'utf-8'));
      if (intervention_info == null) {
        console.log("no intervention_info for intervention " + info_yaml_filepath);
        continue;
      }
      if (intervention_info.disabled) {
        continue;
      }
      intervention_name = info_yaml_filepath.replace(/^src\/interventions\//, '').replace(/\/info\.yaml$/, '');
      intervention_name_to_info[intervention_name] = intervention_info;
    }
    goal_name_to_info = {};
    for (i$ = 0, len$ = (ref$ = glob.sync('src/goals/**/info.yaml')).length; i$ < len$; ++i$) {
      info_yaml_filepath = ref$[i$];
      goal_info = jsYaml.safeLoad(fs.readFileSync(info_yaml_filepath, 'utf-8'));
      if (goal_info == null) {
        console.log("no goal_info for goal " + info_yaml_filepath);
        continue;
      }
      if (goal_info.disabled) {
        continue;
      }
      goal_name = info_yaml_filepath.replace(/^src\/goals\//, '').replace(/\/info\.yaml$/, '');
      goal_name_to_info[goal_name] = goal_info;
    }
    for (i$ = 0, len$ = (ref$ = prelude.sort(Object.keys(goal_name_to_info))).length; i$ < len$; ++i$) {
      goal_name = ref$[i$];
      goal_info = goal_name_to_info[goal_name];
      if (goal_info == null) {
        continue;
      }
      goal_info.name = goal_name;
      if (goal_info.sitename == null) {
        goal_info.sitename = goal_name.split('/')[0];
      }
      if (goal_info.sitename_printable == null) {
        goal_info.sitename_printable = goal_info.sitename.substr(0, 1).toUpperCase() + goal_info.sitename.substr(1);
      }
      if (goal_info.homepage == null) {
        goal_info.homepage = "https://www." + goal_info.sitename + ".com/";
      }
      interventions_for_goal_new = [];
      if (goal_info.interventions == null) {
        console.log('goal is missing interventions: ' + goal_name);
        continue;
      }
      generic_intervention_categories = ['generic', 'generic_positive', 'video'];
      generic_intervention_name_to_specific_name = {};
      for (j$ = 0, len1$ = (ref1$ = goal_info.interventions).length; j$ < len1$; ++j$) {
        intervention_name = ref1$[j$];
        generic_intervention_name_to_specific_name[intervention_name] = intervention_name;
        for (k$ = 0, len2$ = generic_intervention_categories.length; k$ < len2$; ++k$) {
          generic_intervention_category = generic_intervention_categories[k$];
          generic_intervention_category_with_slash = generic_intervention_category + '/';
          if (intervention_name.startsWith(generic_intervention_category_with_slash)) {
            generic_intervention = intervention_name;
            make_absolute_path = fn$;
            intervention_info = JSON.parse(JSON.stringify(intervention_name_to_info[generic_intervention]));
            intervention_name = goal_info.sitename + '/' + generic_intervention.substr(generic_intervention_category_with_slash.length);
            intervention_info.generic_intervention = generic_intervention;
            intervention_info.matches = [goal_info.domain];
            if (intervention_info.content_scripts != null) {
              intervention_info.content_scripts = intervention_info.content_scripts.map(make_absolute_path);
            }
            if (intervention_info.background_scripts != null) {
              intervention_info.background_scripts = intervention_info.background_scripts.map(make_absolute_path);
            }
            intervention_name_to_info[intervention_name] = intervention_info;
            generic_intervention_name_to_specific_name[generic_intervention] = intervention_name;
          }
        }
        intervention_info = intervention_name_to_info[intervention_name];
        if (intervention_info == null) {
          console.log('error: goal ' + goal_info.name + ' lists nonexistent intervention ' + intervention_name);
          continue;
        }
        intervention_info.goals = [goal_info.name];
        interventions_for_goal_new.push(intervention_name);
      }
      goal_info.interventions = interventions_for_goal_new;
      if (goal_info.default_interventions != null) {
        goal_info.default_interventions = goal_info.default_interventions.map(fn1$);
      } else {
        goal_info.default_interventions = goal_info.interventions;
      }
      goal_name_to_info[goal_name] = goal_info;
      goals.push(goal_info);
    }
    for (i$ = 0, len$ = (ref$ = prelude.sort(Object.keys(intervention_name_to_info))).length; i$ < len$; ++i$) {
      intervention_name = ref$[i$];
      intervention_info = intervention_name_to_info[intervention_name];
      intervention_info.name = intervention_name;
      generic_name = (ref1$ = intervention_info.generic_intervention) != null ? ref1$ : intervention_name;
      if (intervention_info.sitename == null) {
        intervention_info.sitename = intervention_name.split('/')[0];
      }
      if (intervention_info.sitename_printable == null) {
        intervention_info.sitename_printable = intervention_info.sitename.substr(0, 1).toUpperCase() + intervention_info.sitename.substr(1);
      }
      is_default = false;
      if (intervention_info.goals != null) {
        for (j$ = 0, len1$ = (ref1$ = intervention_info.goals).length; j$ < len1$; ++j$) {
          goal_name = ref1$[j$];
          goal_info = goal_name_to_info[goal_name];
          if (goal_info.default_interventions != null && goal_info.default_interventions.includes(intervention_name)) {
            is_default = true;
          }
        }
      }
      intervention_info.is_default = is_default;
      interventions.push(intervention_info);
    }
    fs.writeFileSync('dist/goal_intervention_info.json', JSON.stringify(output));
    return done();
    function fn$(content_script){
      if (content_script.path != null) {
        if (content_script.path[0] === '/') {
          return content_script;
        }
        content_script.path = '/interventions/' + generic_intervention + '/' + content_script.path;
        return content_script;
      }
      if (content_script[0] === '/') {
        return content_script;
      }
      return '/interventions/' + generic_intervention + '/' + content_script;
    }
    function fn1$(it){
      return generic_intervention_name_to_specific_name[it];
    }
  });
  gulp.task('generate_libs_frontend', function(done){
    var i$, ref$, len$, lib_name, lib_contents;
    mkdirp.sync('src/generated_libs/libs_frontend');
    for (i$ = 0, len$ = (ref$ = prelude.sort(function_signatures.list_libs())).length; i$ < len$; ++i$) {
      lib_name = ref$[i$];
      lib_contents = "// This file is generated from libs_common/function_signatures.ls\n// Do not edit this file directly. To regenerate, run gulp\nconst {import_lib} = require('libs_frontend/import_lib');\nmodule.exports = import_lib('" + lib_name + "');\n";
      fs.writeFileSync("src/generated_libs/libs_frontend/" + lib_name + ".js", lib_contents);
    }
    return done();
  });
  gulp.task('generate_expose_backend_libs', function(done){
    var output, i$, ref$, len$, lib_name;
    mkdirp.sync('src/generated_libs/libs_backend');
    output = [];
    output.push("const {expose_lib} = require('libs_backend/expose_lib');");
    for (i$ = 0, len$ = (ref$ = prelude.sort(function_signatures.list_libs())).length; i$ < len$; ++i$) {
      lib_name = ref$[i$];
      output.push("expose_lib('" + lib_name + "', require('libs_backend/" + lib_name + "'));");
    }
    output.push('');
    fs.writeFileSync("src/generated_libs/libs_backend/expose_backend_libs.js", output.join("\n"));
    return done();
  });
  gulp.task('generate_jspm_config_frontend', function(done){
    var get_alias_info, output, path_map, i$, ref$, len$, alias_info, path, frontend, libname, package_json_file, package_json;
    get_alias_info = require('./alias_utils').get_alias_info;
    output = [];
    path_map = {};
    for (i$ = 0, len$ = (ref$ = get_alias_info()).length; i$ < len$; ++i$) {
      alias_info = ref$[i$];
      path = alias_info.path, frontend = alias_info.frontend;
      path_map[path] = frontend;
    }
    for (i$ = 0, len$ = (ref$ = fs.readdirSync('src/modules_custom')).length; i$ < len$; ++i$) {
      libname = ref$[i$];
      if (libname.startsWith('.')) {
        continue;
      }
      package_json_file = "src/modules_custom/" + libname + "/package.json";
      package_json = JSON.parse(fs.readFileSync(package_json_file, 'utf-8'));
      path_map[libname] = "modules_custom/" + libname + "/" + package_json.main;
    }
    fs.writeFileSync('jspm_config_frontend.js', "SystemJS.config({\nmap: " + JSON.stringify(path_map, null, 2) + "\n});");
    return done();
  });
  gulp.task('generate_jspm_config_backend', function(done){
    var get_alias_info, output, path_map, i$, ref$, len$, alias_info, path, backend, libname, package_json_file, package_json;
    get_alias_info = require('./alias_utils').get_alias_info;
    output = [];
    path_map = {};
    for (i$ = 0, len$ = (ref$ = get_alias_info()).length; i$ < len$; ++i$) {
      alias_info = ref$[i$];
      path = alias_info.path, backend = alias_info.backend;
      path_map[path] = backend;
    }
    for (i$ = 0, len$ = (ref$ = fs.readdirSync('src/modules_custom')).length; i$ < len$; ++i$) {
      libname = ref$[i$];
      if (libname.startsWith('.')) {
        continue;
      }
      package_json_file = "src/modules_custom/" + libname + "/package.json";
      package_json = JSON.parse(fs.readFileSync(package_json_file, 'utf-8'));
      path_map[libname] = "modules_custom/" + libname + "/" + package_json.main;
    }
    fs.writeFileSync('jspm_config_backend.js', "SystemJS.config({\nmap: " + JSON.stringify(path_map, null, 2) + "\n});");
    return done();
  });
  gulp.task('generate_jspm_config', gulp.parallel('generate_jspm_config_frontend', 'generate_jspm_config_backend'));
  gulp.task('generate_polymer_components_html', function(done){
    var output, i$, ref$, len$, filepath, file_name;
    output = [];
    output.push('<!-- This file is generated by gulp. Do not edit -->');
    for (i$ = 0, len$ = (ref$ = prelude.sort(glob.sync('src/components/**/*.html'))).length; i$ < len$; ++i$) {
      filepath = ref$[i$];
      file_name = filepath.replace(/^src\/components\//, '');
      if (file_name === 'components.html') {
        continue;
      }
      output.push("<link rel='import' href='" + file_name + "'>");
    }
    output.push('');
    fs.writeFileSync('src/components/components.html', output.join("\n"));
    return done();
  });
  extra_folders = ['modules_custom', 'intervention_templates', 'generated_libs', 'bundles', 'bower_components', 'libs_frontend', 'libs_common', 'libs_backend', 'components'];
  gulp.task('make_extra_file_list', function(done){
    var complete_file_list, i$, ref$, len$, subfolder, j$, ref1$, len1$, entry;
    complete_file_list = [];
    for (i$ = 0, len$ = (ref$ = extra_folders).length; i$ < len$; ++i$) {
      subfolder = ref$[i$];
      for (j$ = 0, len1$ = (ref1$ = glob.sync('dist/' + subfolder + '/**')).length; j$ < len1$; ++j$) {
        entry = ref1$[j$];
        entry = entry.replace('dist/', '');
        complete_file_list.push(entry);
      }
    }
    fs.writeFileSync('dist/extra_file_list.json', JSON.stringify(complete_file_list));
    return done();
  });
  gulp.task('remove_extra_files', function(done){
    var i$, ref$, len$, subfolder;
    for (i$ = 0, len$ = (ref$ = extra_folders).length; i$ < len$; ++i$) {
      subfolder = ref$[i$];
      fse.removeSync('dist/' + subfolder);
    }
    return done();
  });
  gulp.task('generate_skate_components_js', function(done){
    var output, all_files, i$, ref$, len$, filepath, file_name;
    output = [];
    output.push('/* This file is generated by gulp. Do not edit */');
    all_files = glob.sync('src/components_skate/**/*.jsx').concat(glob.sync('src/components_skate/**/*.ls'));
    for (i$ = 0, len$ = (ref$ = prelude.sort(all_files)).length; i$ < len$; ++i$) {
      filepath = ref$[i$];
      file_name = filepath.replace(/^src\//, '').replace(/\.jsx$/, '').replace(/\.ls$/, '');
      output.push("require('" + file_name + "')");
    }
    output.push('');
    fs.writeFileSync('src/components_skate/components_skate.js', output.join("\n"));
    return done();
  });
  gulp.task('set_is_debug_build_true', function(done){
    is_debug_build = true;
    return done();
  });
  gulp.task('build_base', gulp.series('set_is_debug_build_true', gulp.parallel(gulp.series('generate_polymer_components_html', 'generate_polymer_dependencies'), gulp.series('generate_jspm_config', 'copy_root_build'), 'generate_libs_frontend', 'generate_expose_backend_libs', 'generate_interventions_list', 'generate_goals_list', 'generate_goal_intervention_info', 'yaml_build', 'copy_build', 'livescript_build', 'copy_interventions'), 'make_extra_file_list'));
  gulp.task('webpack_build', function(){
    return run_gulp_webpack(webpack_config_nowatch);
  });
  gulp.task('webpack_watch', function(){
    return run_gulp_webpack(webpack_config_watch);
  });
  gulp.task('webpack_prod', function(){
    return run_gulp_webpack(webpack_config_prod_nowatch);
  });
  gulp.task('webpack_content_scripts', function(){
    return run_gulp_webpack(webpack_config_nowatch_content_scripts, {
      src_pattern: webpack_pattern_content_scripts
    });
  });
  gulp.task('webpack_content_scripts_watch', function(){
    return run_gulp_webpack(webpack_config_watch_content_scripts, {
      src_pattern: webpack_pattern_content_scripts
    });
  });
  gulp.task('webpack_content_scripts_prod', function(){
    return run_gulp_webpack(webpack_config_prod_nowatch_content_scripts, {
      src_pattern: webpack_pattern_content_scripts
    });
  });
  gulp.task('html_srcgen', function(){
    return gulp.src(htmlpattern_srcgen, {
      base: 'src'
    }).pipe(gulpChanged('src_gen')).pipe(gulp.dest('src_gen'));
  });
  gulp.task('vulcanize', gulp.series(gulp.parallel('livescript_srcgen', 'js_srcgen', 'html_srcgen'), function(){
    return gulp.src(vulcanize_html_pattern, {
      base: 'src_gen'
    }).pipe(gulpVulcanize({
      inlineScripts: true,
      inlineCss: false
    })).pipe(gulpCrisper({})).pipe(gulp.dest('src_vulcanize'));
  }));
  gulp.task('copy_vulcanize', gulp.series('vulcanize', function(){
    return gulp.src(vulcanize_html_output_pattern, {
      base: 'src_vulcanize'
    }).pipe(gulp.dest('dist'));
  }));
  /*
  tasks_and_patterns = [
    #['livescript_build', lspattern]
    #['copy_vulcanize', vulcanize_watch_pattern]
    #['typescript', tspattern]
    #['es6', es6pattern]
    ['yaml', yamlpattern]
    #['browserify_js', browserify_js_pattern]
    #['browserify_ls', browserify_ls_pattern]
    ['copy', copypattern]
    #['eslint', eslintpattern]
    #['livescript_browserify', lspattern_browserify]
  ]
  */
  gulp.task('make_docs_markdown', function(done){
    var exec;
    exec = require('shelljs').exec;
    if (!fs.existsSync('doc')) {
      fs.mkdirSync('doc');
    }
    exec('node ./node_modules/documentation-habitlab/bin/documentation.js build src_gen/libs_frontend/*.js src_gen/libs_backend/*.js src_gen/libs_common/*.js src/flowtypes/*.js -f md -o doc/API.md --github');
    fse.copySync('doc/API.md', 'dist/API.md');
    return done();
  });
  gulp.task('make_docs', gulp.series('livescript_srcgen', 'js_srcgen', 'make_docs_markdown'));
  gulp.task('build', gulp.parallel('build_base', 'webpack_build', 'webpack_content_scripts'));
  gulp.task('listcomponents', function(){
    return run_gulp_webpack(webpack_config_nowatch_content_scripts_listcomponents, {
      src_pattern: webpack_pattern_content_scripts
    });
  });
  gulp.task('print_components_to_rename', async function(done){
    var storage, components_list;
    storage = require('node-persist');
    (await storage.init());
    components_list = (await storage.keys());
    console.log(components_list);
    return done();
  });
  gulp.task('build_release', gulp.parallel(gulp.series('build_base', 'make_docs_markdown'), 'webpack_prod', 'webpack_content_scripts_prod'));
  mkzip_function = function(actually_delete, suffix, done){
    var manifest_info, version, output_zip_file, files_to_skip, input_files, i$, ref$, len$, filename, skip_file, x, j$, ref1$, len1$, extra_folder;
    mkdirp.sync('releases');
    manifest_info = jsYaml.safeLoad(fs.readFileSync('src/manifest.yaml'));
    version = manifest_info.version;
    output_zip_file = path.join('releases', "habitlab_" + version + ".zip");
    if (suffix != null && suffix.length > 0) {
      output_zip_file = path.join('releases', "habitlab_" + version + "_" + suffix + ".zip");
    }
    if (fs.existsSync('mkzip_tmp')) {
      fse.removeSync('mkzip_tmp');
    }
    mkdirp.sync('mkzip_tmp');
    files_to_skip = ['interventions/interventions.json', 'goals/goals.json', 'API.md', 'popup_loader.js', 'index_jspm.html', 'index_jspm.js', 'index_loader.js', 'index.js', 'systemjs_paths.js', 'logs.html', 'logs.js'];
    input_files = [];
    for (i$ = 0, len$ = (ref$ = glob.sync('dist/**')).length; i$ < len$; ++i$) {
      filename = ref$[i$];
      if (!fs.lstatSync(filename).isFile()) {
        continue;
      }
      skip_file = false;
      x = filename.replace('dist/', '');
      for (j$ = 0, len1$ = (ref1$ = extra_folders).length; j$ < len1$; ++j$) {
        extra_folder = ref1$[j$];
        if (x.startsWith(extra_folder)) {
          skip_file = true;
        }
      }
      if (x.endsWith('/info.json') && (x.startsWith('goals/') || x.startsWith('interventions/'))) {
        skip_file = true;
      }
      if (skip_file) {
        continue;
      }
      if (files_to_skip.includes(x)) {
        continue;
      }
      input_files.push(filename);
    }
    for (i$ = 0, len$ = input_files.length; i$ < len$; ++i$) {
      x = input_files[i$];
      fse.ensureFileSync(x.replace('dist/', 'mkzip_tmp/'));
      fse.copySync(x, x.replace('dist/', 'mkzip_tmp/'));
    }
    if (!actually_delete) {
      done();
      return;
    }
    return bestzip(output_zip_file, ['mkzip_tmp/*'], function(){
      fse.removeSync('mkzip_tmp');
      done();
    });
  };
  gulp.task('mkzip_fake', function(done){
    return mkzip_function(false, null, done);
  });
  gulp.task('mkzip', function(done){
    return mkzip_function(true, null, done);
  });
  gulp.task('mkzip_beta', function(done){
    return mkzip_function(true, 'beta', done);
  });
  gulp.task('mkzip_release', function(done){
    return mkzip_function(true, 'release', done);
  });
  gulp.task('buildmanifest_beta', function(done){
    var manifest_file_contents, manifest_file_extra;
    manifest_file_contents = jsYaml.safeLoad(fs.readFileSync('src/manifest.yaml'));
    if (is_debug_build) {
      manifest_file_contents.devtools_page = 'devtools.html';
    }
    if (fs.existsSync('src/manifest_extra_beta.yaml')) {
      manifest_file_extra = jsYaml.safeLoad(fs.readFileSync('src/manifest_extra_beta.yaml'));
      manifest_file_contents = deepmerge(manifest_file_contents, manifest_file_extra);
    }
    fs.writeFileSync('dist/manifest.json', JSON.stringify(manifest_file_contents, null, 2));
    return done();
  });
  gulp.task('buildmanifest_release', function(done){
    var manifest_file_contents, manifest_file_extra;
    manifest_file_contents = jsYaml.safeLoad(fs.readFileSync('src/manifest.yaml'));
    if (is_debug_build) {
      manifest_file_contents.devtools_page = 'devtools.html';
    }
    if (fs.existsSync('src/manifest_extra_release.yaml')) {
      manifest_file_extra = jsYaml.safeLoad(fs.readFileSync('src/manifest_extra_release.yaml'));
      manifest_file_contents = deepmerge(manifest_file_contents, manifest_file_extra);
    }
    fs.writeFileSync('dist/manifest.json', JSON.stringify(manifest_file_contents, null, 2));
    return done();
  });
  gulp.task('mkzip_beta', gulp.series('buildmanifest_beta', 'mkzip_beta'));
  gulp.task('mkzip_release', gulp.series('buildmanifest_release', 'mkzip_release'));
  get_latest_published_version = async function(){
    var latest_published_version, i$, ref$, len$, extension_id, chrome_store_item, published_version;
    latest_published_version = '0.0.0';
    for (i$ = 0, len$ = (ref$ = ['obghclocpdgcekcognpkblghkedcpdgd', 'bleifeoekkfhicamkpadfoclfhfmmina']).length; i$ < len$; ++i$) {
      extension_id = ref$[i$];
      chrome_store_item = (await chromeWebStoreItemProperty(extension_id));
      published_version = chrome_store_item.version;
      if (semver.gt(published_version, latest_published_version)) {
        latest_published_version = published_version;
      }
    }
    return latest_published_version;
  };
  gulp.task('newver', async function(done){
    var published_version, manifest_info, version, version_parts;
    published_version = (await get_latest_published_version());
    manifest_info = jsYaml.safeLoad(fs.readFileSync('src/manifest.yaml'));
    version = manifest_info.version;
    if (published_version === version) {
      version_parts = version.split('.');
      version_parts[version_parts.length - 1] = (parseInt(version_parts[version_parts.length - 1]) + 1).toString();
      manifest_info.version = version_parts.join('.');
      fs.writeFileSync('src/manifest.yaml', jsYaml.safeDump(manifest_info));
    }
    if (done != null) {
      done();
    }
  });
  gulp.task('newver_forced', function(done){
    var manifest_info, version, version_parts;
    manifest_info = jsYaml.safeLoad(fs.readFileSync('src/manifest.yaml'));
    version = manifest_info.version;
    version_parts = version.split('.');
    version_parts[version_parts.length - 1] = (parseInt(version_parts[version_parts.length - 1]) + 1).toString();
    manifest_info.version = version_parts.join('.');
    fs.writeFileSync('src/manifest.yaml', jsYaml.safeDump(manifest_info));
    return done();
  });
  gulp.task('yaml_watch_base', function(){
    return gulp.watch(yamlpattern_base, gulp.series('yaml_build_base'));
  });
  gulp.task('yaml_watch_manifest', function(){
    return gulp.watch(yamlpattern_manifest, gulp.series('yaml_build_manifest'));
  });
  gulp.task('yaml_watch', gulp.parallel('yaml_watch_base', 'yaml_watch_manifest'));
  gulp.task('copy_watch', function(){
    return gulp.watch(copypattern, gulp.series('copy_build'));
  });
  gulp.task('copy_root_watch', function(){
    return gulp.watch(copyrootpattern, gulp.series('copy_root_build'));
  });
  gulp.task('livescript_watch', function(){
    return gulp.watch(lspattern, gulp.series('livescript_build'));
  });
  gulp.task('generate_skate_components_js_watch', function(){
    return gulp.watch(['src/components_skate/**/*.jsx', 'src/components_skate/**/*.ls'], gulp.series('generate_skate_components_js'));
  });
  gulp.task('generate_polymer_dependencies_watch', function(){
    return gulp.watch(['src/components/**/*.html', '!src/components/components.html'], gulp.series('generate_polymer_components_html', 'generate_polymer_dependencies'));
  });
  gulp.task('generate_libs_frontend_watch', function(){
    return gulp.watch(['src/libs_common/function_signatures.ls'], gulp.parallel('generate_expose_backend_libs', 'generate_libs_frontend'));
  });
  gulp.task('generate_interventions_list_watch', function(){
    return gulp.watch(['src/interventions/**/info.yaml'], gulp.series('generate_interventions_list'));
  });
  gulp.task('generate_goals_list_watch', function(){
    return gulp.watch(['src/goals/**/info.yaml'], gulp.series('generate_goals_list'));
  });
  gulp.task('generate_goal_intervention_info_watch', function(){
    return gulp.watch(['src/interventions/**/info.yaml', 'src/goals/**/info.yaml'], gulp.series('generate_goal_intervention_info'));
  });
  gulp.task('watch_base', gulp.parallel('webpack_watch', 'webpack_content_scripts_watch', 'yaml_watch', 'copy_watch', 'copy_root_watch', 'livescript_watch', 'generate_polymer_dependencies_watch', 'generate_libs_frontend_watch', 'generate_interventions_list_watch', 'generate_goals_list_watch', 'generate_goal_intervention_info_watch'));
  /*
  gulp.task 'watch_base', gulp.parallel 'webpack_watch', 'webpack_content_scripts_watch', ->
    for [task,pattern] in tasks_and_patterns
      gulp.watch pattern, [task]
    return
  */
  gulp.task('lint', gulp.series('eslint'));
  gulp.task('lint_watch', gulp.series('lint', function(){
    return gulp.watch(eslintpattern, gulp.series('eslint'));
  }));
  gulp.task('clean', function(){
    return del(['dist', 'src_vulcanize', 'src_gen', 'src/generated_libs', 'src/**/*.deps.js', 'src/**/*.jspm.js', 'src/components/components.html']);
  });
  /*
  gulp.task 'watch', ['build'], (done) ->
    gulp-util.log 'run-sequence starting'
    <- run-sequence ['webpack_watch', 'webpack_content_scripts_watch', 'lint_watch']
    gulp-util.log 'run-sequence done'
    done()
  */
  gulp.task('release', gulp.series('newver', 'clean', 'build_release', 'mkzip_beta', 'mkzip_release'));
  gulp.task('releasenew', gulp.series('clean', 'build_release', 'mkzip_beta', 'mkzip_release'));
  gulp.task('fakerelease', gulp.series('build', 'mkzip_fake'));
  gulp.task('watch', gulp.series('build_base', gulp.parallel('watch_base', 'lint', 'lint_watch', 'make_docs_markdown')));
  gulp.task('livereload', function(){
    var livereload_server;
    livereload_server = livereload.createServer({
      applyCSSLive: false,
      applyImgLive: false,
      exclusions: ['*.jspm.js', 'components/*', 'components/**/*'],
      delay: 500
    });
    return livereload_server.watch(['dist/index.js']);
  });
  gulp.task('default', gulp.parallel('watch', 'livereload'));
}).call(this);
